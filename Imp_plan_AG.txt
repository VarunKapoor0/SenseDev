Analysis Engine Upgrade - Method-Level Call Graph
Critical Gaps Identified
Based on the updated planning document, the current implementation has these critical issues:

Shallow Edges: Only file-level references (imports), not method-level calls
No Edge Types: Edges are unlabeled instead of typed (CALLS, USES_SENSOR_DATA, etc.)
No Data Flow: Not tracking LiveData/StateFlow propagation
No Method Call Graph: Only showing "MainActivity → everything" instead of actual call chains
No Real Flows: Missing SENSOR_SOURCE → LOGIC → VIEWMODEL → UI paths
Proposed Fixes
Phase 1: Enhance Parsing to Extract Method Calls
[MODIFY] 
core/parser/KotlinParser.kt
Current: Only captures method names
New: Extract actual method calls from method bodies using regex patterns
Look for patterns like:
someMethod(...)
object.method(...)
SensorManager.registerListener
Store in MethodSymbol.callsTo as list of qualified method names
[MODIFY] 
core/parser/JavaParserAdapter.kt
Use JavaParser's MethodCallExpr visitor
Extract method call expressions from method body AST
Map to qualified names where possible
Phase 2: Add Edge Type Labels
[MODIFY] 
core/graph/GraphBuilder.kt
Current: Creates edges between classes only
New:
Create method-level nodes OR encode method calls in edge labels
Properly type edges using 
EdgeType
 enum
Add CALLS edges for method invocations
Add WRITES_STATE / READS_STATE for LiveData/StateFlow access
Add USES_SENSOR_DATA for sensor callbacks
[NEW] 
core/graph/MethodNode.kt
Alternative approach: Create nodes at method granularity, not just class granularity
Each method becomes a node
Edges represent actual calls
Phase 3: Improve Sensor Detection at Method Level
[MODIFY] 
core/sensor/SensorDetector.kt
Current: Basic pattern matching
New:
Look inside method bodies for sensor API calls
Detect registerListener calls and extract sensor type from parameters
Track which methods actually contain sensor operations
Return method-level entry points, not just class-level
Phase 4: Build Real Data Flow Paths
[MODIFY] 
core/graph/FlowExtractor.kt
Current: Simplistic path tracing
New:
Start from methods marked as SENSOR_SOURCE
Follow CALLS edges through the graph
Track state writes (LiveData, StateFlow assignments)
Continue following to UI nodes (Composables, Activities)
Build complete flow: Sensor → Repo → VM → UI
Phase 5: Enhanced Graph Visualization
[MODIFY] 
ui/graph/GraphPanel.kt
Display edge labels showing edge type
Different edge colors for different types:
CALLS: black
USES_SENSOR_DATA: red
WRITES_STATE/READS_STATE: blue
Hover over edge to show source location
Implementation Approach
Option A: Class-Level with Rich Edges (Simpler, MVP)
Keep nodes at class level
Make edges much richer:
Edge labels show method names
Edge types properly set
Multiple edges between same two classes OK
Pros: Less refactoring, works with current UI
Cons: Less precise, harder to show method-level detail
Option B: Method-Level Nodes (More Complex, Ideal)
Create nodes for each method
Edges represent actual method calls
Group methods by class in UI with expand/collapse
Pros: Perfect precision, true call graph
Cons: More nodes, need hierarchical UI
Recommendation: Start with Option A, refine to Option B later if needed.

Immediate Action Items
✅ Update 
KotlinParser
 to extract method calls from bodies
✅ Update 
JavaParserAdapter
 to extract method calls
✅ Modify 
GraphBuilder
 to create method-level edges with types
✅ Update 
SensorDetector
 to work at method level
✅ Fix 
FlowExtractor
 to build real end-to-end paths
✅ Update 
GraphPanel
 to show edge labels/types
Success Criteria
When analyzing a sensor app like SenseMap, we should see:

AccelerometerCallback.onSensorChanged [SENSOR_SOURCE]
  --[CALLS]--> SensorRepository.updateAccel
    --[WRITES_STATE]--> StateFlow<AccelData>
      --[READS_STATE]--> SenseViewModel
        --[CALLS]--> SenseScreen [UI]
Not just:

MainActivity --(unlabeled)-> SensorRepository
MainActivity --(unlabeled)-> ViewModel